#' Negated value matching
#'
#' This operator is a negated version of \%in\%.
#'
#' @param x vector or `NULL`; the values to be matched.
#' @param table vector or `NULL`; the values to be matched against.
#'
#' @return a vector of the same length as x
#' @export
#'
`%nin%` <- function(x, table) {
  !x %in% table
}

#

#' Augment a dataframe
#'
#' Augment a dataframe with the median of a variable in each bin, and with a
#' bin identifier for that variable. The bin sizes are chosen by
#' `ggplot2::cut_number` so that there will be have approximately equal counts
#' in each bin.
#'
#' @param df a dataframe
#' @param var a tidy-select column specification
#' @param nbins the number of bins to generate
#'
#' @return a tibble with two new columns, for the var's bin number and the var's
#'          median
#' @export
#'
augment_bins <- function(df, var, nbins=25)
{
  # Capture the argument as a quosure
  v <- rlang::enquo(var)
  # Get the string representation of the variable
  vname <- rlang::as_string(rlang::quo_get_expr(v))
  # add a new column named bin_column_name carrying the bin number for each row.
  tmp <- dplyr::mutate(df, ibin = ggplot2::cut_number(!!v, nbins, labels=FALSE))
  # Determine the median of the variable var in each bin.
  tmp2 <- dplyr::group_by(tmp, .data$ibin) |>
    dplyr::summarize(xxx = median(!!v), .groups="drop")
  # Give the new column a more appropriate name.
  names(tmp2)[length(tmp2)] <- paste0(vname, "_median")
  # Now augment the original dataframe with the new column
  tmp <- dplyr::left_join(tmp, tmp2, by="ibin")
  names(tmp)[length(tmp)-1] <- paste0(vname, "_bin")
  tmp
}

#' Read benchmark output generated by nanobench,
#'
#' This function expects the output in the style written for Linux machines,
#' which includes columns not collected on macOS.
#'
#' @param filename the name of the file with nanobench output to read.
#'
#' @return a tibble
#' @export
#' @importFrom read.so read_md
#'
read_benchmark <- function(filename)
{
  d <- read_md(filename)
  if(length(d) == 10) {
    names(d) <- c("time", "op_sec", "err_frac", "instructions_op", "cycles_op", "ipc", "branches_op", "miss_frac", "total", "name")
    d$miss_frac <- as.numeric(sub("%", "", d$miss_frac))/100
  }
  if (length(d) == 5)
  {
    names(d) <- c("time", "op_sec","err_frac", "total", "name")
  }
  d$err_frac <- as.numeric(sub("%","",d$err_frac))/100
  d$name <- gsub("`", "", d$name, fixed=TRUE)
  d
}

#' Convenience functions for calling grep
#'
#' This function is a copy of the one in data.table. It is intended to be used
#' through the associated operator, \%like\%.
#'
#' @param vector Either a character or factor vector
#' @param pattern Pattern to be matched
#' @param ignore.case logical: is the matching to be case-insensitive?
#' @param fixed logical: is `pattern` to be interpreted as a literal string?
#' @param perl logical: is the pattern a Perl-compatible regular expression?
#'
#' @return logical vector, TRUE for items that match the pattern
#' @export
#'
like <- function (vector, pattern, ignore.case = FALSE, fixed = FALSE, perl = FALSE)
{
  if (is.factor(vector)) {
    ret = grepl(pattern, levels(vector), ignore.case = ignore.case, fixed = fixed, perl = perl)[vector]
    ret[is.na(ret)] = FALSE
    ret
  } else {
    grepl(pattern, vector, ignore.case = ignore.case, fixed = fixed, perl = perl)
  }
}

"%like%" <- like
